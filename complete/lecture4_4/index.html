<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lecture 4.4 â€“ AR place on floor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />

  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; }
    #btns {
      position: absolute; right: 10px; top: 10px; z-index: 10;
      display:flex; gap:6px; flex-wrap:wrap;
    }
    #hint {
      position: absolute; left: 50%; transform: translateX(-50%);
      bottom: 14px; z-index: 10; color: white; font-family: system-ui, Arial, sans-serif;
      font-size: 14px; padding: 6px 10px; background: rgba(0,0,0,0.5); border-radius: 8px;
    }
    button {
      padding: 6px 10px; border: 1px solid #fff3; background: #111; color: #fff; border-radius: 6px; cursor: pointer;
    }
    button:hover { background:#222; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="btns">
    <button id="btn1">Idle</button>
    <button id="btn2">Dance</button>
    <button id="btn3">Die</button>
    <button id="btn4">Walk</button>
    <button id="btnAR">Enter AR</button>
  </div>
  <div id="hint" hidden>Beweeg je telefoon om een vlak te vinden. Tik om te plaatsen.</div>

  <script type="module">
    // --- imports via CDN (werkt prima op GitHub Pages) ---
    import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
    import { ARButton } from 'https://unpkg.com/three@0.165.0/examples/jsm/webxr/ARButton.js';

    // === Stel dit in op jouw poppetje (.glb) ===
    // Zet bijv. je model in dezelfde map en noem het 'character.glb'
    const MODEL_URL = './character.glb'; // <-- PAS DIT AAN naar jouw pad

    let scene, camera, renderer, clock;
    let reticle, hitTestSource = null, hitTestSourceRequested = false;
    let mixer = null, model = null, currentAction = null, actions = {};
    const hint = document.getElementById('hint');

    // renderer
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // scene & camera
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 50);

    // licht
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    hemi.position.set(0, 1, 0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(1, 2, 1);
    scene.add(dir);

    // vloer-grid (alleen in non-AR preview)
    const grid = new THREE.GridHelper(10, 10, 0x888888, 0x444444);
    grid.visible = true;
    scene.add(grid);

    // reticle voor AR plaatsing
    reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.14, 0.18, 32).rotateX(-Math.PI / 2),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    clock = new THREE.Clock();

    // model vooraf laden (zodat animaties klaar staan)
    const loader = new GLTFLoader();
    loader.load(MODEL_URL, (gltf) => {
      model = gltf.scene;
      model.visible = false;            // pas tonen zodra geplaatst
      model.scale.setScalar(1.0);       // schaal eventueel aanpassen
      scene.add(model);

      mixer = new THREE.AnimationMixer(model);
      gltf.animations.forEach((clip) => {
        actions[clip.name] = mixer.clipAction(clip);
      });

      // Kies een default actie als die bestaat:
      const fallback = actions['Idle'] || actions[Object.keys(actions)[0]];
      if (fallback) {
        currentAction = fallback;
        currentAction.play();
      }

      // UI animatieknoppen
      document.getElementById('btn1').onclick = () => playAction('Idle');
      document.getElementById('btn2').onclick = () => playAction('Dance');
      document.getElementById('btn3').onclick = () => playAction('Die');
      document.getElementById('btn4').onclick = () => playAction('Walk');
    });

    function playAction(name) {
      if (!mixer || !actions[name]) return;
      if (currentAction === actions[name]) return;
      const next = actions[name];
      next.reset().play();
      if (currentAction) currentAction.crossFadeTo(next, 0.25, false);
      currentAction = next;
    }

    // ARButton
    const arButton = ARButton.createButton(renderer, {
      requiredFeatures: ['hit-test'] // floor placement
    });
    // We tonen onze eigen knop:
    arButton.style.display = 'none';
    document.getElementById('btnAR').onclick = () => {
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSessionInit({ requiredFeatures: ['hit-test'] });
      arButton.click(); // start AR sessie via verborgen ARButton
    };

    // XR events
    renderer.xr.addEventListener('sessionstart', () => {
      grid.visible = false;
      hint.hidden = false;
      hitTestSourceRequested = false;
      hitTestSource = null;
    });

    renderer.xr.addEventListener('sessionend', () => {
      grid.visible = true;
      hint.hidden = true;
      reticle.visible = false;
      hitTestSourceRequested = false;
      hitTestSource = null;
      if (model) {
        model.visible = true; // laat staan in non-AR, eventueel op 0,0,0
        model.position.set(0, 0, 0);
      }
    });

    // Tik om te plaatsen
    const controller = renderer.xr.getController(0);
    controller.addEventListener('select', () => {
      if (reticle.visible && model) {
        // plaats model op reticle
        model.visible = true;
        model.position.setFromMatrixPosition(reticle.matrix);
        // laat hem naar camera kijken (optioneel): model.lookAt(camera.position);
      }
    });
    scene.add(controller);

    // render loop
    renderer.setAnimationLoop((timestamp, frame) => {
      const dt = clock.getDelta();
      if (mixer) mixer.update(dt);

      // hit-test voor reticle
      if (frame) {
        const session = renderer.xr.getSession();
        const refSpace = renderer.xr.getReferenceSpace();

        if (!hitTestSourceRequested) {
          session.requestReferenceSpace('viewer').then((viewerSpace) => {
            session.requestHitTestSource({ space: viewerSpace }).then((source) => {
              hitTestSource = source;
            });
          });
          session.addEventListener('end', () => {
            hitTestSourceRequested = false;
            hitTestSource = null;
          });
          hitTestSourceRequested = true;
        }

        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(refSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }

      renderer.render(scene, camera);
    });

    // resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
